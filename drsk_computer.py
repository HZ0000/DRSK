# -*- coding: utf-8 -*-
"""DRSK-Computer.ipynb

Automatically generated by Colaboratory.

"""

import sympy as sp
import numpy as np
import cvxpy as cp
import math
import scipy.stats as st
import scipy

from numpy import genfromtxt
datatr = genfromtxt('CF3-100mean-MCMC1.csv', delimiter=',') #
datatr = datatr[1:,1:]
print(datatr.shape)
print(np.mean(datatr[:,12]))

np.random.shuffle(datatr)
h1 = -0.001
h2 = 1
n1 = 12  #dimension of x
n2 = 20  #simulation times
ratio= 0.5  #m=ratio*n
B0 = 50
mea= 0.007252683 #0.008103 #0.00697
lik = st.gamma
prior = st.gamma
sigma = 1
eps = 0.00001
naccept = 0
niters = 20


for h111 in [1]:
  tttt = 0.01
  for n3 in range(20, 200, 20): #n3 the size of entire data
    m=int(ratio*n3) #m the size of the first batch
    m2=n3-m #m2 the size of the second batch
    sum21=0
    sum22=0
    sum23=0
    sum24=0
    sum25=0
    sum26=0
    sum27=0
    sum28=0
    lam=tttt*m**(-1/2)  #lambda
    print("m, m2, lambda", m, m2, lam)
    checkvar=np.zeros([n2])
    for i1 in range(n2):
        #np.random.shuffle(datatr)
        rows = datatr[i1*n3:(i1+1)*n3, :]
        p1 = rows[:,:n1] #+np.random.normal(size=(n3,n1))
        p2 = np.zeros([n3,1],dtype=int)
        q1 = np.zeros([m2,n1])
        q2 = np.zeros([m2,1],dtype=int)
        for i in range(n3):
          p2[i,0] = int(i) #the index used to identify the label for p1
        for i in range(m2):
            q1[i] = p1[i+m]   #x_j
            q2[i] = p2[i+m]  #y_j

        h1=-1/((np.median(scipy.spatial.distance.pdist(p1)))**2)*h111


        def uti(args): #u(x) Jacobian
            u0 = []
            para = [0.4, 0.6, 0.5, 0.3, 0.4, 1.0, 0.3, 1.2, 0.7, 0.6, 0.5, 0.4]
            #para = [0.3, 0.5, 0.4, 0.2, 0.3, 1.1, 0.2, 1.0, 0.9, 0.5, 0.4, 0.3]
            #para = [0.5, 0.7, 0.6, 0.4, 0.4, 1.2, 0.3, 1.2, 1.0, 0.8, 0.7, 0.5]
            for i in range(n1):
              u0.append(19/(args[i])-para[i])
            return u0

        def k10(args, args2):  #the original k
            sum1 = 0
            sum2 = 0
            for i in range(n1):
                sum1= sum1+(args[i]-args2[i])**2
            sum2=h2*math.exp(h1*sum1)
            return sum2

        def k0(args, args2):  #the k0
            sum1=0
            for i in range(n1):
                sum1= sum1+ k10(args, args2)*(-4*(h1**2)*((args[i]-args2[i])**2)-2*h1)+ uti(args)[i]* k10(args, args2)*(2*h1*(args2[i]-args[i])) +uti(args2)[i]* k10(args, args2)*(2*h1*(args[i]-args2[i]))+uti(args)[i]*uti(args2)[i]*k10(args, args2)
            return sum1

        def k1(args, args2):  #the k+
            return k0(args, args2)+1

        def f1(args, args2):  #the f(x,y)
            return rows[args2[0],n1]

        K1 = np.zeros([m,m])  #K+ of the first batch
        for i in range(m):
            for j in range(m):
                K1[i,j]=k1(p1[i],p1[j])

        K0 = np.zeros([m2,m2])  #K0 of the second batch
        for i in range(m2):
            for j in range(m2):
                K0[i,j]=k0(q1[i],q1[j])
        K0 = K0 + eps * np.eye(m2)

        z = np.zeros([m])   #z of the first batch
        for i in range(len(z)):
            z[i]=f1(p1[i],p2[i])

        I0=np.eye(m)
        bel0 = np.linalg.inv(K1+lam*m*I0)
        bel1 = np.dot(bel0,z)     #beta of the first batch

        def s1(args):  #sm(x)
            sum1 = 0
            for i in range(m):
                sum1= sum1+bel1[i]*k1(p1[i], args)
            return sum1


        s2=np.sum(bel1)

        def f2(args, args2):   #fm
            return f1(args, args2)-s1(args)+s2


        # Define and solve the quadratic problem using the second batch
        I1=np.eye(m2)
        e1 = []
        e2 = []
        e3 = []
        for i in range(m2):
            e1.append(1)
            e2.append(0)
            e3.append(B0/m2)

        w1 = cp.Variable(m2)
        K0=cp.atoms.affine.wraps.psd_wrap(K0)
        prob = cp.Problem(cp.Minimize(cp.quad_form(w1, K0)),
                         [I1@w1 >= e2,
                          I1@w1 <= e3,
                          e1@w1 == 1])
        prob.solve()


        K0_IS = np.zeros([n3,n3])  #K0 of the entire data
        for i in range(n3):
            for j in range(n3):
                K0_IS[i,j]=k0(p1[i],p1[j])
        K0_IS = K0_IS + eps * np.eye(n3)

        # Define and solve the quadratic problem using the entire data
        I1_IS=np.eye(n3)
        e1_IS = []
        e2_IS = []
        e3_IS = []
        for i in range(n3):
            e1_IS.append(1)
            e2_IS.append(0)
            e3_IS.append(B0/n3)

        w1_IS = cp.Variable(n3)
        K0_IS_w=cp.atoms.affine.wraps.psd_wrap(K0_IS)
        prob_IS = cp.Problem(cp.Minimize(cp.quad_form(w1_IS, K0_IS_w)),
                         [I1_IS@w1_IS >= e2_IS,
                          I1_IS@w1_IS <= e3_IS,
                          e1_IS@w1_IS == 1])
        prob_IS.solve()


        K1_IS = K0_IS - eps * np.eye(n3) + np.ones((n3,n3)) #K+ of the second batch
        bel0_IS = np.linalg.inv(K1_IS+tttt*(n3**(1/2))*np.eye(n3))
        z_IS = np.zeros((n3))   #z of the entire data
        for i in range(n3):
          z_IS[i]=f1(p1[i],p2[i])
        bel1_IS = np.dot(bel0_IS,z_IS) #beta of the first data


        def f10():   #Sample mean: sum of f
            sum1=0
            for i in range(m2):
                sum1=sum1+(1/m2)*f1(q1[i], q2[i])
            return sum1

        def f20():   #CF(original): sum of fm on the second batch
            sum1=0
            for i in range(m2):
                sum1=sum1+(1/m2)*f2(q1[i], q2[i])
            return sum1

        def f30():   #weighted sum of f on the second batch (only for fun, not the original BBIS)
            sum1=0
            for i in range(m2):
                sum1=sum1+(w1.value[i])*f1(q1[i], q2[i])
            return sum1

        def f40():   #DRSK(original): weighted sum of fm, using the first and second batch separately
            sum1=0
            for i in range(m2):
                sum1=sum1+(w1.value[i])*f2(q1[i], q2[i])
            return sum1


        def f50():   #BBIS: weighted sum of f
            sum1=0
            for i in range(n3):
                sum1=sum1+(w1_IS.value[i])*f1(p1[i], p2[i])
            return sum1

        def f60():   #weighted sum of fm where fm is only constructed from the second batch
            sum1=0
            for i in range(n3):
                sum1=sum1+(w1_IS.value[i])*f2(p1[i], p2[i])
            return sum1
        #print("weighted sum of f",f30())
        #print("weighted sum of fm",f40())
        #print("s2",s2())
        #for i in range(m):
        #    print (f1(q1[i], q2[i]))

        def s1_IS(args):  #s_n(x): from the entire data
            sum1 = 0
            for i in range(n3):
                sum1= sum1+bel1_IS[i]*k1(p1[i], args)
            return sum1

        s2_IS=np.sum(bel1_IS) #CF-sim: from the entire data
        def f3(args, args2):
            return f1(args, args2)-s1_IS(args)+s2_IS

        def f70():   #DRSK-R: weighted sum of fn where fn is constructed from the entire data
            sum1=0
            for i in range(n3):
                sum1=sum1+(w1_IS.value[i])*f3(p1[i], p2[i])
            return sum1



        sum21=sum21+(f10()-mea)**2
        sum22=sum22+(f20()-mea)**2
        sum23=sum23+(f30()-mea)**2
        sum24=sum24+(f40()-mea)**2
        sum25=sum25+(s2_IS-mea)**2
        sum26=sum26+(f50()-mea)**2
        sum27=sum27+(f70()-mea)**2
        sum28=sum28+(f60()-mea)**2
        #checkvar[i1]=s2_IS
    print([sum22/n2,sum26/n2,sum24/n2,sum27/n2,sum25/n2])
